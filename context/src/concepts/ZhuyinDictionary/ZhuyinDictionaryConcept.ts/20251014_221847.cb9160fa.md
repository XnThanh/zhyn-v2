---
timestamp: 'Tue Oct 14 2025 22:18:47 GMT-0400 (Eastern Daylight Time)'
content_id: cb9160fa8e4fd97f6164888912b6bcb59ac43f94c37797cfaadb4122f4fa7349
---

# file: src\concepts\ZhuyinDictionary\ZhuyinDictionaryConcept.ts

```typescript
import { Collection, Db } from "npm:mongodb";
import { Empty, ID } from "@utils/types.ts";

// Generic types for this concept: Character and ZhuyinRep are treated as opaque IDs.
type Character = ID;
type ZhuyinRep = ID;

// Internal entity type representing a character entry in the dictionary
interface CharacterEntry {
  _id: Character; // The character itself acts as the unique identifier
  zhuyinRep: ZhuyinRep;
}

/**
 * @concept ZhuyinDictionary
 * @purpose Track Characters and their Zhuyin Representation
 */
export default class ZhuyinDictionaryConcept {
  private readonly charactersCollection: Collection<CharacterEntry>;
  private readonly PREFIX = "ZhuyinDictionary" + ".";

  constructor(private readonly db: Db) {
    this.charactersCollection = this.db.collection(this.PREFIX + "characters");
  }

  /**
   * **action** register (character: Character, zhuyinRep: ZhuyinRep)
   *
   * @requires Character doesn't already exist
   * @effects add Character and associate with that ZhuyinRep
   */
  async register(
    { character, zhuyinRep }: {
      character: Character;
      zhuyinRep: ZhuyinRep;
    },
  ): Promise<Empty | { error: string }> {
    // Check if character already exists
    const existing = await this.charactersCollection.findOne({
      _id: character,
    });
    if (existing) {
      return { error: `Character '${character}' already registered.` };
    }

    // Insert the new character and its Zhuyin representation
    await this.charactersCollection.insertOne({ _id: character, zhuyinRep });
    return {};
  }

  /**
   * **action** unregister (character: Character)
   *
   * @requires Character already exist
   * @effects remove Character and corresponding ZhuyinRep
   */
  async unregister(
    { character }: {
      character: Character;
    },
  ): Promise<Empty | { error: string }> {
    // Check if character exists
    const existing = await this.charactersCollection.findOne({
      _id: character,
    });
    if (!existing) {
      return { error: `Character '${character}' not found.` };
    }

    // Delete the character entry
    await this.charactersCollection.deleteOne({ _id: character });
    return {};
  }

  /**
   * **action** getAnswer (character: Character): (zhuyinRep: ZhuyinRep)
   *
   * @effects returns the ZhuyinRep associated with the Character
   */
  async getAnswer(
    { character }: {
      character: Character;
    },
  ): Promise<{ zhuyinRep: ZhuyinRep } | { error: string }> {
    const entry = await this.charactersCollection.findOne({ _id: character });
    if (!entry) {
      return {
        error: `Zhuyin representation for character '${character}' not found.`,
      };
    }
    return { zhuyinRep: entry.zhuyinRep };
  }

  /**
   * **action** lookupZhuyin (zhuyinRep: ZhuyinRep): (characters: Character[])
   *
   * @effects Returns a list of all Characters whose Zhuyin representation matches zhuyinRep.
   * The pattern can be a full Zhuyin string, a partial prefix, or even support wildcards for more advanced search.
   * This allows users to find all characters with a specific pronunciation.
   */
  async lookupZhuyin(
    { zhuyinRep }: { zhuyinRep: ZhuyinRep },
  ): Promise<{ characters: Character[] }> {
    // For "partial prefix" and "wildcards", we use a regex query.
    // The given zhuyinRep is treated as a prefix.
    const query = { zhuyinRep: { $regex: `^${zhuyinRep}`, $options: "i" } }; // Case-insensitive prefix match

    const entries = await this.charactersCollection.find(query).toArray();
    const characters = entries.map((entry) => entry._id);
    return { characters };
  }
}

```
